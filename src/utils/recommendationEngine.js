// recommendationEngine.js v1.2 - LUCIDE ICON NAMES
// Three-layer system: Rules + Existing Metrics + LLM Insights
// Leverages existing customerMetrics.js calculations
//
// CHANGELOG:
// v1.2 (2026-02-07): Replace emoji icons with Lucide icon name strings
//   - All rules and metrics use Lucide icon names instead of emoji characters
//   - Added ICON_MAP export mapping icon names to Lucide components
// v1.1 (2026-02-06): Add customerIds to actionData for smart modal actions
//   - CAM-001, CAM-003, CHURN-001, DEGRADE-001, CONVERT-001 now include customerIds
//   - requestLLMInsight simplified: server gathers context from Supabase
// v1.0 (2026-02-06): Initial implementation
//   - Layer 1: Rule-based triggers (instant)
//   - Layer 2: Existing metrics from customerMetrics.js (returnLikelihood, degradation)
//   - Layer 3: LLM insights fetched from Supabase (generated by scheduled Netlify function)

import getSupabaseClient from './supabaseClient';
import { getFrequencyDegradation, getRetentionMetrics, getFirstVisitConversion } from './customerMetrics';

// Maps recommendation actionType to navigation tab IDs
export const ACTION_TO_TAB = {
  create_campaign: 'campaigns',
  view_customer: 'diretorio',
  view_customers: 'customers',
  view_dashboard: 'dashboard',
};

// ============================================
// LAYER 1: RULE-BASED TRIGGERS
// ============================================

const RULE_CHECKS = [
  {
    id: 'CAM-001',
    category: 'campaign',
    icon: 'target',
    priority: 8,
    expiresHours: 48,
    check: ({ customers }) => {
      const slipping = (customers || []).filter(c =>
        c.daysSinceLastVisit >= 25 && c.daysSinceLastVisit <= 35 && c.hasValidPhone
      );
      if (slipping.length >= 10) {
        return {
          title: `${slipping.length} clientes precisam de atenção`,
          description: `Clientes que não visitam há 25-35 dias. Uma campanha agora pode recuperá-los antes que se percam.`,
          actionType: 'create_campaign',
          actionLabel: 'Criar Campanha',
          actionData: { segment: 'slipping', customerCount: slipping.length, customerIds: slipping.map(c => c.doc).filter(Boolean) }
        };
      }
      return null;
    }
  },
  {
    id: 'CAM-002',
    category: 'campaign',
    icon: 'crown',
    priority: 9,
    expiresHours: 72,
    check: ({ customers }) => {
      const inactiveVIPs = (customers || []).filter(c =>
        c.segment === 'VIP' && c.daysSinceLastVisit >= 15 && c.hasValidPhone
      );
      if (inactiveVIPs.length > 0) {
        const topVIP = inactiveVIPs.sort((a, b) => (b.netTotal || 0) - (a.netTotal || 0))[0];
        return {
          title: `VIP ${topVIP.name} não visita há ${topVIP.daysSinceLastVisit} dias`,
          description: `Cliente top (R$${(topVIP.netTotal || 0).toLocaleString('pt-BR')} gasto total). Contato pessoal recomendado.`,
          actionType: 'view_customer',
          actionLabel: 'Ver Cliente',
          actionData: { customerId: topVIP.doc, customerName: topVIP.name }
        };
      }
      return null;
    }
  },
  {
    id: 'CAM-003',
    category: 'campaign',
    icon: 'user-plus',
    priority: 7,
    expiresHours: 48,
    check: ({ customers }) => {
      const newNeverReturned = (customers || []).filter(c =>
        c.visits === 1 &&
        c.daysSinceLastVisit >= 7 && c.daysSinceLastVisit <= 30 &&
        c.hasValidPhone
      );
      if (newNeverReturned.length >= 5) {
        return {
          title: `${newNeverReturned.length} novos clientes aguardando 2ª visita`,
          description: `Estes clientes vieram uma vez e não voltaram. Uma campanha de boas-vindas pode incentivá-los.`,
          actionType: 'create_campaign',
          actionLabel: 'Criar Campanha',
          actionData: { segment: 'new_customers', customerCount: newNeverReturned.length, customerIds: newNeverReturned.map(c => c.doc).filter(Boolean) }
        };
      }
      return null;
    }
  },
  {
    id: 'CEL-001',
    category: 'celebration',
    icon: 'trophy',
    priority: 5,
    expiresHours: 48,
    check: ({ customers }) => {
      const milestones = (customers || []).filter(c => {
        const count = c.visits || 0;
        return (count === 10 || count === 25 || count === 50) && c.daysSinceLastVisit <= 3;
      });
      if (milestones.length > 0) {
        const c = milestones[0];
        return {
          title: `${c.name} completou ${c.visits} visitas!`,
          description: `Um marco de fidelidade! Considere enviar uma mensagem de agradecimento.`,
          actionType: 'view_customer',
          actionLabel: 'Ver Cliente',
          actionData: { customerId: c.doc, customerName: c.name }
        };
      }
      return null;
    }
  }
];

// ============================================
// LAYER 2: EXISTING METRICS
// ============================================

function generateMetricsRecommendations(data) {
  const recommendations = [];
  const { customers, salesData, customerMap } = data;

  // 2A. HIGH CHURN RISK — existing returnLikelihood
  const highChurnRisk = (customers || []).filter(c =>
    c.returnLikelihood !== undefined &&
    c.returnLikelihood < 30 &&
    c.riskLevel !== 'Lost' &&
    c.riskLevel !== 'New Customer' &&
    c.visits >= 2
  );

  if (highChurnRisk.length >= 5) {
    const totalValue = highChurnRisk.reduce((sum, c) => sum + (c.netTotal || 0), 0);
    recommendations.push({
      ruleId: 'CHURN-001',
      category: 'churn',
      icon: 'shield-alert',
      priority: 9,
      expiresHours: 72,
      title: `${highChurnRisk.length} clientes com alto risco de churn`,
      description: `Clientes com <30% probabilidade de retorno. Valor em risco: R$${totalValue.toLocaleString('pt-BR')}`,
      actionType: 'view_customers',
      actionLabel: 'Ver Clientes em Risco',
      actionData: { filter: 'high_churn_risk', count: highChurnRisk.length, customerIds: highChurnRisk.map(c => c.doc).filter(Boolean) },
      aiConfidence: 1 - (highChurnRisk[0]?.returnLikelihood || 50) / 100
    });
  }

  // 2B. FREQUENCY DEGRADATION — existing getFrequencyDegradation()
  if (salesData && customerMap && salesData.length > 0) {
    try {
      const degradation = getFrequencyDegradation(salesData, customerMap);

      if (degradation.priorityCount > 0) {
        recommendations.push({
          ruleId: 'DEGRADE-001',
          category: 'churn',
          icon: 'trending-down',
          priority: 8,
          expiresHours: 72,
          title: `${degradation.priorityCount} VIPs com frequência caindo`,
          description: `Clientes importantes visitando com menos frequência (média +${degradation.avgDegradation}% de intervalo entre visitas).`,
          actionType: 'view_customers',
          actionLabel: 'Ver Clientes',
          actionData: { filter: 'degrading_frequency', count: degradation.priorityCount, customerIds: degradation.customers.filter(c => c.isPriority).map(c => c.doc).filter(Boolean) }
        });
      }
    } catch (err) {
      console.error('getFrequencyDegradation failed:', err);
    }
  }

  // 2C. FIRST VISIT CONVERSION — existing getFirstVisitConversion()
  if (salesData && customerMap && salesData.length > 0) {
    try {
      const conversion = getFirstVisitConversion(salesData, customerMap);

      if (conversion.pending > 5 && conversion.rate < 50) {
        recommendations.push({
          ruleId: 'CONVERT-001',
          category: 'campaign',
          icon: 'refresh-cw',
          priority: 7,
          expiresHours: 72,
          title: `Taxa de conversão 1ª→2ª visita: ${conversion.rate}%`,
          description: `${conversion.pending} novos clientes ainda não voltaram. Uma campanha de boas-vindas pode melhorar essa taxa.`,
          actionType: 'view_dashboard',
          actionLabel: 'Ver Detalhes',
          actionData: { tab: 'customers', customerIds: (conversion.pendingCustomers || []).map(c => c.id || c.doc).filter(Boolean) }
        });
      }
    } catch (err) {
      console.error('getFirstVisitConversion failed:', err);
    }
  }

  // 2D. RETENTION TREND — existing getRetentionMetrics()
  if (salesData && customerMap && salesData.length > 0) {
    try {
      const retention = getRetentionMetrics(salesData, customerMap);

      if (retention.current && retention.previous) {
        const trendDiff = (retention.current.rate || 0) - (retention.previous.rate || 0);
        if (trendDiff < -5) {
          recommendations.push({
            ruleId: 'RETAIN-001',
            category: 'alert',
            icon: 'alert-triangle',
            priority: 8,
            expiresHours: 168,
            title: `Retenção caiu ${Math.abs(Math.round(trendDiff))}% vs período anterior`,
            description: `Taxa atual: ${retention.current.rate}%. Menos clientes estão retornando dentro de 30 dias.`,
            actionType: 'view_dashboard',
            actionLabel: 'Ver Detalhes',
            actionData: { tab: 'customers' }
          });
        }
      }
    } catch (err) {
      console.error('getRetentionMetrics failed:', err);
    }
  }

  return recommendations;
}

// ============================================
// LAYER 3: LLM INSIGHTS (Fetch from DB)
// ============================================

async function fetchLLMInsights() {
  const supabase = await getSupabaseClient();
  if (!supabase) return [];

  const { data } = await supabase
    .from('active_recommendations')
    .select('*')
    .eq('ai_generated', true)
    .limit(10);

  return (data || []).map(r => ({
    ...r,
    ruleId: r.rule_id,
    actionType: r.action_type,
    actionLabel: r.action_label,
    actionData: r.action_data,
    aiGenerated: r.ai_generated,
    aiModel: r.ai_model,
    aiConfidence: r.ai_confidence ? parseFloat(r.ai_confidence) : null,
    expiresAt: r.expires_at
  }));
}

// Request on-demand LLM insight (calls Netlify function)
// Server gathers all context from Supabase — no frontend metrics needed
export async function requestLLMInsight(insightType) {
  const apiKey = import.meta.env.VITE_API_KEY;
  const response = await fetch('/.netlify/functions/ai-insights', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...(apiKey && { 'X-Api-Key': apiKey })
    },
    body: JSON.stringify({ insightType })
  });

  if (!response.ok) {
    const body = await response.json().catch(() => ({}));
    throw new Error(body.error || 'Erro ao gerar análise IA');
  }
  return response.json();
}

// ============================================
// MAIN ENGINE
// ============================================

export async function generateRecommendations(data) {
  const recommendations = [];
  const today = new Date().toISOString().split('T')[0];

  // Layer 1: Rule-based checks
  for (const rule of RULE_CHECKS) {
    try {
      const result = rule.check(data);
      if (result) {
        recommendations.push({
          ruleId: rule.id,
          category: rule.category,
          icon: rule.icon,
          priority: rule.priority,
          aiGenerated: false,
          fingerprint: `${rule.id}-${today}`,
          expiresAt: new Date(Date.now() + (rule.expiresHours || 48) * 60 * 60 * 1000).toISOString(),
          ...result
        });
      }
    } catch (error) {
      console.error(`Rule ${rule.id} failed:`, error);
    }
  }

  // Layer 2: Existing metrics
  try {
    const metricsRecs = generateMetricsRecommendations(data);
    recommendations.push(...metricsRecs.map(r => ({
      ...r,
      aiGenerated: false,
      fingerprint: `${r.ruleId}-${today}`,
      expiresAt: new Date(Date.now() + (r.expiresHours || 72) * 60 * 60 * 1000).toISOString()
    })));
  } catch (error) {
    console.error('Metrics recommendations failed:', error);
  }

  // Layer 3: Fetch existing LLM insights from DB
  try {
    const llmInsights = await fetchLLMInsights();
    recommendations.push(...llmInsights);
  } catch (error) {
    console.error('LLM insights fetch failed:', error);
  }

  // Deduplicate by fingerprint (keep highest priority)
  const seen = new Map();
  for (const rec of recommendations) {
    const key = rec.fingerprint || rec.ruleId;
    if (!seen.has(key) || (rec.priority || 0) > (seen.get(key).priority || 0)) {
      seen.set(key, rec);
    }
  }

  // Sort by priority (highest first)
  return Array.from(seen.values()).sort((a, b) => (b.priority || 5) - (a.priority || 5));
}

// Save recommendations to DB (for persistence/history)
export async function saveRecommendation(rec) {
  const supabase = await getSupabaseClient();
  if (!supabase) return;

  const { error } = await supabase
    .from('recommendations')
    .upsert({
      rule_id: rec.ruleId,
      category: rec.category,
      icon: rec.icon,
      title: rec.title,
      description: rec.description,
      action_type: rec.actionType,
      action_label: rec.actionLabel,
      action_data: rec.actionData,
      priority: rec.priority,
      expires_at: rec.expiresAt,
      ai_generated: rec.aiGenerated || false,
      ai_model: rec.aiModel || null,
      ai_confidence: rec.aiConfidence || null,
      fingerprint: rec.fingerprint
    }, {
      onConflict: 'fingerprint',
      ignoreDuplicates: true
    });

  if (error) console.error('Error saving recommendation:', error);
}

// Dismiss a recommendation
export async function dismissRecommendation(id) {
  const supabase = await getSupabaseClient();
  if (!supabase) return;

  await supabase
    .from('recommendations')
    .update({ dismissed_at: new Date().toISOString() })
    .eq('id', id);
}

// Snooze a recommendation
export async function snoozeRecommendation(id, hours = 24) {
  const supabase = await getSupabaseClient();
  if (!supabase) return;

  const snoozeUntil = new Date(Date.now() + hours * 60 * 60 * 1000).toISOString();
  await supabase
    .from('recommendations')
    .update({ snoozed_until: snoozeUntil })
    .eq('id', id);
}

// Mark recommendation as actioned
export async function markActioned(id) {
  const supabase = await getSupabaseClient();
  if (!supabase) return;

  await supabase
    .from('recommendations')
    .update({ actioned_at: new Date().toISOString() })
    .eq('id', id);
}
